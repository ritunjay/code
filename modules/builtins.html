<html><head>
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        </head><body><table class='table'><thead> Method name </thead><thead>Method description</thead><tbody><tr><td>ArithmeticError</td><td>Base class for arithmetic errors.</td><tr><td>AssertionError</td><td>Assertion failed.</td><tr><td>AttributeError</td><td>Attribute not found.</td><tr><td>BaseException</td><td>Common base class for all exceptions</td><tr><td>BufferError</td><td>Buffer error.</td><tr><td>BytesWarning</td><td>Base class for warnings about bytes and buffer related problems, mostly related to conversion from str or comparing to str.</td><tr><td>DeprecationWarning</td><td>Base class for warnings about deprecated features.</td><tr><td>EOFError  </td><td>Read beyond end of file.</td><tr><td>Ellipsis  </td><td>None</td><tr><td>EnvironmentError</td><td>Base class for I/O related errors.</td><tr><td>Exception </td><td>Common base class for all non-exit exceptions.</td><tr><td>False     </td><td>bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</td><tr><td>FloatingPointError</td><td>Floating point operation failed.</td><tr><td>FutureWarning</td><td>Base class for warnings about constructs that will change semantically in the future.</td><tr><td>GeneratorExit</td><td>Request that a generator exit.</td><tr><td>IOError   </td><td>I/O operation failed.</td><tr><td>ImportError</td><td>Import can't find module, or can't find name in module.</td><tr><td>ImportWarning</td><td>Base class for warnings about probable mistakes in module imports</td><tr><td>IndentationError</td><td>Improper indentation.</td><tr><td>IndexError</td><td>Sequence index out of range.</td><tr><td>KeyError  </td><td>Mapping key not found.</td><tr><td>KeyboardInterrupt</td><td>Program interrupted by user.</td><tr><td>LookupError</td><td>Base class for lookup errors.</td><tr><td>MemoryError</td><td>Out of memory.</td><tr><td>NameError </td><td>Name not found globally.</td><tr><td>None      </td><td>None</td><tr><td>NotImplemented</td><td>None</td><tr><td>NotImplementedError</td><td>Method or function hasn't been implemented yet.</td><tr><td>OSError   </td><td>OS system call failed.</td><tr><td>OverflowError</td><td>Result too large to be represented.</td><tr><td>PendingDeprecationWarning</td><td>Base class for warnings about features which will be deprecated in the future.</td><tr><td>ReferenceError</td><td>Weak ref proxy used after referent went away.</td><tr><td>RuntimeError</td><td>Unspecified run-time error.</td><tr><td>RuntimeWarning</td><td>Base class for warnings about dubious runtime behavior.</td><tr><td>StandardError</td><td>Base class for all standard Python exceptions that do not represent interpreter exiting.</td><tr><td>StopIteration</td><td>Signal the end from iterator.next().</td><tr><td>SyntaxError</td><td>Invalid syntax.</td><tr><td>SyntaxWarning</td><td>Base class for warnings about dubious syntax.</td><tr><td>SystemError</td><td>Internal error in the Python interpreter. Please report this to the Python maintainer, along with the traceback, the Python version, and the hardware/OS platform and version.</td><tr><td>SystemExit</td><td>Request to exit from the interpreter.</td><tr><td>TabError  </td><td>Improper mixture of spaces and tabs.</td><tr><td>True      </td><td>bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</td><tr><td>TypeError </td><td>Inappropriate argument type.</td><tr><td>UnboundLocalError</td><td>Local name referenced but not bound to a value.</td><tr><td>UnicodeDecodeError</td><td>Unicode decoding error.</td><tr><td>UnicodeEncodeError</td><td>Unicode encoding error.</td><tr><td>UnicodeError</td><td>Unicode related error.</td><tr><td>UnicodeTranslateError</td><td>Unicode translation error.</td><tr><td>UnicodeWarning</td><td>Base class for warnings about Unicode related problems, mostly related to conversion problems.</td><tr><td>UserWarning</td><td>Base class for warnings generated by user code.</td><tr><td>ValueError</td><td>Inappropriate argument value (of correct type).</td><tr><td>Warning   </td><td>Base class for warning categories.</td><tr><td>ZeroDivisionError</td><td>Second argument to a division or modulo operation was zero.</td><tr><td>__debug__ </td><td>bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</td><tr><td>__doc__   </td><td>str(object='') -> string Return a nice string representation of the object. If the argument is a string, the return value is the same object.</td><tr><td>__import__</td><td>__import__(name, globals={}, locals={}, fromlist=[], level=-1) -> module Import a module. Because this function is meant for use by the Python interpreter and not for general use it is better to use importlib.import_module() to programmatically import a module. The globals argument is only used to determine the context; they are not modified. The locals argument is unused. The fromlist should be a list of names to emulate ``from name import ...'', or an empty list to emulate ``import name''. When importing a module from a package, note that __import__('A.B', ...) returns package A when fromlist is empty, but its submodule B when fromlist is not empty. Level is used to determine whether to perform absolute or relative imports. -1 is the original strategy of attempting both absolute and relative imports, 0 is absolute, a positive number is the number of parent directories to search relative to the current module.</td><tr><td>__name__  </td><td>str(object='') -> string Return a nice string representation of the object. If the argument is a string, the return value is the same object.</td><tr><td>__package__</td><td>None</td><tr><td>abs       </td><td>abs(number) -> number Return the absolute value of the argument.</td><tr><td>all       </td><td>all(iterable) -> bool Return True if bool(x) is True for all values x in the iterable. If the iterable is empty, return True.</td><tr><td>any       </td><td>any(iterable) -> bool Return True if bool(x) is True for any x in the iterable. If the iterable is empty, return False.</td><tr><td>apply     </td><td>apply(object[, args[, kwargs]]) -> value Call a callable object with positional arguments taken from the tuple args, and keyword arguments taken from the optional dictionary kwargs. Note that classes are callable, as are instances with a __call__() method. Deprecated since release 2.3. Instead, use the extended call syntax: function(*args, **keywords).</td><tr><td>basestring</td><td>Type basestring cannot be instantiated; it is the base for str and unicode.</td><tr><td>bin       </td><td>bin(number) -> string Return the binary representation of an integer or long integer.</td><tr><td>bool      </td><td>bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</td><tr><td>buffer    </td><td>buffer(object [, offset[, size]]) Create a new buffer object which references the given object. The buffer will reference a slice of the target object from the start of the object (or at the specified offset). The slice will extend to the end of the target object (or with the specified size).</td><tr><td>bytearray </td><td>bytearray(iterable_of_ints) -> bytearray. bytearray(string, encoding[, errors]) -> bytearray. bytearray(bytes_or_bytearray) -> mutable copy of bytes_or_bytearray. bytearray(memory_view) -> bytearray. Construct an mutable bytearray object from: - an iterable yielding integers in range(256) - a text string encoded using the specified encoding - a bytes or a bytearray object - any object implementing the buffer API. bytearray(int) -> bytearray. Construct a zero-initialized bytearray of the given length.</td><tr><td>bytes     </td><td>str(object='') -> string Return a nice string representation of the object. If the argument is a string, the return value is the same object.</td><tr><td>callable  </td><td>callable(object) -> bool Return whether the object is callable (i.e., some kind of function). Note that classes are callable, as are instances with a __call__() method.</td><tr><td>chr       </td><td>chr(i) -> character Return a string of one character with ordinal i; 0 <= i < 256.</td><tr><td>classmethod</td><td>classmethod(function) -> method Convert a function to be a class method. A class method receives the class as implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom: class C: def f(cls, arg1, arg2, ...): ... f = classmethod(f) It can be called either on the class (e.g. C.f()) or on an instance (e.g. C().f()). The instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument. Class methods are different than C++ or Java static methods. If you want those, see the staticmethod builtin.</td><tr><td>cmp       </td><td>cmp(x, y) -> integer Return negative if x<y, zero if x==y, positive if x>y.</td><tr><td>coerce    </td><td>coerce(x, y) -> (x1, y1) Return a tuple consisting of the two numeric arguments converted to a common type, using the same rules as used by arithmetic operations. If coercion is not possible, raise TypeError.</td><tr><td>compile   </td><td>compile(source, filename, mode[, flags[, dont_inherit]]) -> code object Compile the source string (a Python module, statement or expression) into a code object that can be executed by the exec statement or eval(). The filename will be used for run-time error messages. The mode must be 'exec' to compile a module, 'single' to compile a single (interactive) statement, or 'eval' to compile an expression. The flags argument, if present, controls which future statements influence the compilation of the code. The dont_inherit argument, if non-zero, stops the compilation inheriting the effects of any future statements in effect in the code calling compile; if absent or zero these statements do influence the compilation, in addition to any features explicitly specified.</td><tr><td>complex   </td><td>complex(real[, imag]) -> complex number Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0.</td><tr><td>copyright </td><td>interactive prompt objects for printing the license text, a list of contributors and the copyright notice.</td><tr><td>credits   </td><td>interactive prompt objects for printing the license text, a list of contributors and the copyright notice.</td><tr><td>delattr   </td><td>delattr(object, name) Delete a named attribute on an object; delattr(x, 'y') is equivalent to ``del x.y''.</td><tr><td>dict      </td><td>dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</td><tr><td>dir       </td><td>dir([object]) -> list of strings If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the attributes of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise the default dir() logic is used and returns: for a module object: the module's attributes. for a class object: its attributes, and recursively the attributes of its bases. for any other object: its attributes, its class's attributes, and recursively the attributes of its class's base classes.</td><tr><td>divmod    </td><td>divmod(x, y) -> (quotient, remainder) Return the tuple ((x-x%y)/y, x%y). Invariant: div*y + mod == x.</td><tr><td>enumerate </td><td>enumerate(iterable[, start]) -> iterator for index, value of iterable Return an enumerate object. iterable must be another object that supports iteration. The enumerate object yields pairs containing a count (from start, which defaults to zero) and a value yielded by the iterable argument. enumerate is useful for obtaining an indexed list: (0, seq[0]), (1, seq[1]), (2, seq[2]), ...</td><tr><td>eval      </td><td>eval(source[, globals[, locals]]) -> value Evaluate the source in the context of globals and locals. The source may be a string representing a Python expression or a code object as returned by compile(). The globals must be a dictionary and locals can be any mapping, defaulting to the current globals and locals. If only globals is given, locals defaults to it.</td><tr><td>execfile  </td><td>execfile(filename[, globals[, locals]]) Read and execute a Python script from a file. The globals and locals are dictionaries, defaulting to the current globals and locals. If only globals is given, locals defaults to it.</td><tr><td>exit      </td><td>None</td><tr><td>file      </td><td>file(name[, mode[, buffering]]) -> file object Open a file. The mode can be 'r', 'w' or 'a' for reading (default), writing or appending. The file will be created if it doesn't exist when opened for writing or appending; it will be truncated when opened for writing. Add a 'b' to the mode for binary files. Add a '+' to the mode to allow simultaneous reading and writing. If the buffering argument is given, 0 means unbuffered, 1 means line buffered, and larger numbers specify the buffer size. The preferred way to open a file is with the builtin open() function. Add a 'U' to mode to open the file for input with universal newline support. Any line ending in the input file will be seen as a '\n' in Python. Also, a file so opened gains the attribute 'newlines'; the value for this attribute is one of None (no newline read yet), '\r', '\n', '\r\n' or a tuple containing all the newline types seen. 'U' cannot be combined with 'w' or '+' mode.</td><tr><td>filter    </td><td>filter(function or None, sequence) -> list, tuple, or string Return those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list.</td><tr><td>float     </td><td>float(x) -> floating point number Convert a string or number to a floating point number, if possible.</td><tr><td>format    </td><td>format(value[, format_spec]) -> string Returns value.__format__(format_spec) format_spec defaults to ""</td><tr><td>frozenset </td><td>frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.</td><tr><td>getattr   </td><td>getattr(object, name[, default]) -> value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case.</td><tr><td>globals   </td><td>globals() -> dictionary Return the dictionary containing the current scope's global variables.</td><tr><td>hasattr   </td><td>hasattr(object, name) -> bool Return whether the object has an attribute with the given name. (This is done by calling getattr(object, name) and catching exceptions.)</td><tr><td>hash      </td><td>hash(object) -> integer Return a hash value for the object. Two objects with the same value have the same hash value. The reverse is not necessarily true, but likely.</td><tr><td>help      </td><td>Define the built-in 'help'. This is a wrapper around pydoc.help (with a twist).</td><tr><td>hex       </td><td>hex(number) -> string Return the hexadecimal representation of an integer or long integer.</td><tr><td>id        </td><td>id(object) -> integer Return the identity of an object. This is guaranteed to be unique among simultaneously existing objects. (Hint: it's the object's memory address.)</td><tr><td>input     </td><td>input([prompt]) -> value Equivalent to eval(raw_input(prompt)).</td><tr><td>int       </td><td>int(x=0) -> int or long int(x, base=10) -> int or long Convert a number or string to an integer, or return 0 if no arguments are given. If x is floating point, the conversion truncates towards zero. If x is outside the integer range, the function returns a long instead. If x is not a number or if base is given, then x must be a string or Unicode object representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4</td><tr><td>intern    </td><td>intern(string) -> string ``Intern'' the given string. This enters the string in the (global) table of interned strings whose purpose is to speed up dictionary lookups. Return the string itself or the previously interned string object with the same value.</td><tr><td>isinstance</td><td>isinstance(object, class-or-type-or-tuple) -> bool Return whether an object is an instance of a class or of a subclass thereof. With a type as second argument, return whether that is the object's type. The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for isinstance(x, A) or isinstance(x, B) or ... (etc.).</td><tr><td>issubclass</td><td>issubclass(C, B) -> bool Return whether class C is a subclass (i.e., a derived class) of class B. When using a tuple as the second argument issubclass(X, (A, B, ...)), is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).</td><tr><td>iter      </td><td>iter(collection) -> iterator iter(callable, sentinel) -> iterator Get an iterator from an object. In the first form, the argument must supply its own iterator, or be a sequence. In the second form, the callable is called until it returns the sentinel.</td><tr><td>len       </td><td>len(object) -> integer Return the number of items of a sequence or mapping.</td><tr><td>license   </td><td>interactive prompt objects for printing the license text, a list of contributors and the copyright notice.</td><tr><td>list      </td><td>list() -> new empty list list(iterable) -> new list initialized from iterable's items</td><tr><td>locals    </td><td>locals() -> dictionary Update and return a dictionary containing the current scope's local variables.</td><tr><td>long      </td><td>long(x=0) -> long long(x, base=10) -> long Convert a number or string to a long integer, or return 0L if no arguments are given. If x is floating point, the conversion truncates towards zero. If x is not a number or if base is given, then x must be a string or Unicode object representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4L</td><tr><td>map       </td><td>map(function, sequence[, sequence, ...]) -> list Return a list of the results of applying the function to the items of the argument sequence(s). If more than one sequence is given, the function is called with an argument list consisting of the corresponding item of each sequence, substituting None for missing values when not all sequences have the same length. If the function is None, return a list of the items of the sequence (or a list of tuples if more than one sequence).</td><tr><td>max       </td><td>max(iterable[, key=func]) -> value max(a, b, c, ...[, key=func]) -> value With a single iterable argument, return its largest item. With two or more arguments, return the largest argument.</td><tr><td>memoryview</td><td>memoryview(object) Create a new memoryview object which references the given object.</td><tr><td>min       </td><td>min(iterable[, key=func]) -> value min(a, b, c, ...[, key=func]) -> value With a single iterable argument, return its smallest item. With two or more arguments, return the smallest argument.</td><tr><td>next      </td><td>next(iterator[, default]) Return the next item from the iterator. If default is given and the iterator is exhausted, it is returned instead of raising StopIteration.</td><tr><td>object    </td><td>The most base type</td><tr><td>oct       </td><td>oct(number) -> string Return the octal representation of an integer or long integer.</td><tr><td>open      </td><td>open(name[, mode[, buffering]]) -> file object Open a file using the file() type, returns a file object. This is the preferred way to open a file. See file.__doc__ for further information.</td><tr><td>ord       </td><td>ord(c) -> integer Return the integer ordinal of a one-character string.</td><tr><td>pow       </td><td>pow(x, y[, z]) -> number With two arguments, equivalent to x**y. With three arguments, equivalent to (x**y) % z, but may be more efficient (e.g. for longs).</td><tr><td>print     </td><td>print(value, ..., sep=' ', end='\n', file=sys.stdout) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline.</td><tr><td>property  </td><td>property(fget=None, fset=None, fdel=None, doc=None) -> property attribute fget is a function to be used for getting an attribute value, and likewise fset is a function for setting, and fdel a function for del'ing, an attribute. Typical use is to define a managed attribute x: class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, "I'm the 'x' property.") Decorators make defining new properties or modifying existing ones easy: class C(object): @property def x(self): "I am the 'x' property." return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x</td><tr><td>quit      </td><td>None</td><tr><td>range     </td><td>range(stop) -> list of integers range(start, stop[, step]) -> list of integers Return a list containing an arithmetic progression of integers. range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0. When step is given, it specifies the increment (or decrement). For example, range(4) returns [0, 1, 2, 3]. The end point is omitted! These are exactly the valid indices for a list of 4 elements.</td><tr><td>raw_input </td><td>raw_input([prompt]) -> string Read a string from standard input. The trailing newline is stripped. If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError. On Unix, GNU readline is used if enabled. The prompt string, if given, is printed without a trailing newline before reading.</td><tr><td>reduce    </td><td>reduce(function, sequence[, initial]) -> value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.</td><tr><td>reload    </td><td>reload(module) -> module Reload the module. The module must have been successfully imported before.</td><tr><td>repr      </td><td>repr(object) -> string Return the canonical string representation of the object. For most object types, eval(repr(object)) == object.</td><tr><td>reversed  </td><td>reversed(sequence) -> reverse iterator over values of the sequence Return a reverse iterator</td><tr><td>round     </td><td>round(number[, ndigits]) -> floating point number Round a number to a given precision in decimal digits (default 0 digits). This always returns a floating point number. Precision may be negative.</td><tr><td>set       </td><td>set() -> new empty set object set(iterable) -> new set object Build an unordered collection of unique elements.</td><tr><td>setattr   </td><td>setattr(object, name, value) Set a named attribute on an object; setattr(x, 'y', v) is equivalent to ``x.y = v''.</td><tr><td>slice     </td><td>slice(stop) slice(start, stop[, step]) Create a slice object. This is used for extended slicing (e.g. a[0:10:2]).</td><tr><td>sorted    </td><td>sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list</td><tr><td>staticmethod</td><td>staticmethod(function) -> method Convert a function to be a static method. A static method does not receive an implicit first argument. To declare a static method, use this idiom: class C: def f(arg1, arg2, ...): ... f = staticmethod(f) It can be called either on the class (e.g. C.f()) or on an instance (e.g. C().f()). The instance is ignored except for its class. Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see the classmethod builtin.</td><tr><td>str       </td><td>str(object='') -> string Return a nice string representation of the object. If the argument is a string, the return value is the same object.</td><tr><td>sum       </td><td>sum(sequence[, start]) -> value Return the sum of a sequence of numbers (NOT strings) plus the value of parameter 'start' (which defaults to 0). When the sequence is empty, return start.</td><tr><td>super     </td><td>super(type, obj) -> bound super object; requires isinstance(obj, type) super(type) -> unbound super object super(type, type2) -> bound super object; requires issubclass(type2, type) Typical use to call a cooperative superclass method: class C(B): def meth(self, arg): super(C, self).meth(arg)</td><tr><td>tuple     </td><td>tuple() -> empty tuple tuple(iterable) -> tuple initialized from iterable's items If the argument is a tuple, the return value is the same object.</td><tr><td>type      </td><td>type(object) -> the object's type type(name, bases, dict) -> a new type</td><tr><td>unichr    </td><td>unichr(i) -> Unicode character Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.</td><tr><td>unicode   </td><td>unicode(object='') -> unicode object unicode(string[, encoding[, errors]]) -> unicode object Create a new Unicode object from the given encoded string. encoding defaults to the current default string encoding. errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.</td><tr><td>vars      </td><td>vars([object]) -> dictionary Without arguments, equivalent to locals(). With an argument, equivalent to object.__dict__.</td><tr><td>xrange    </td><td>xrange(stop) -> xrange object xrange(start, stop[, step]) -> xrange object Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is slightly faster than range() and more memory efficient.</td><tr><td>zip       </td><td>zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)] Return a list of tuples, where each tuple contains the i-th element from each of the argument sequences. The returned list is truncated in length to the length of the shortest argument sequence.</td></tbody></table></body></html>